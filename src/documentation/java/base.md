---
title: Java基础

---

### 1.什么是面向对象？面向对象和面向过程的区别
“面向过程”是一种以过程为中心的编程思想。分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候依次调用就可以了。

“面向对象”是一种以事物为中心的编程思想，把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为。

### 2.面向对象的三大特性
封装、继承、多态

- 封装：对外只暴露最小完整可用接口，隐藏内部实现细节
- 继承：某个类型的对象获得另一个类型对象的属性的方法
- 多态：指一个类实例的相同方法在不同情形有不同的表现形式

### 3.JDK、JRE、JVM三者之间的关系

- JDK：是Java开发工具包，包含了jre，Java工具，Java基础的类库
- JRE：Java运行环境，运行Java所需
- JVM：Java虚拟机，它是整个Java实现跨平台的最核心部分，所有的Java程序首先被编译为.class文件，这种类型的文件可以在虚拟机上运行

### 4.重载和重写的区别
重载：在同一个类中，方法名相同，返回值类型、参数列表不同
重写：在继承中，方法名相同，返回值类型，参数列表相同

Java中是否可以重写一个private或者static方法？
答：不能，重写是在继承中，private修饰的方法只能当前类访问，继承类没有权限访问，所以不能重写，static方法是编译时静态绑定的，而重写是运行时动态绑定的，所以不能重写

### 5.构造方法有哪些特性
构造方法主要是初始化类对象，可以执行，当一个类没有声明构造方法时，也会有默认的不带参数的构造方法执行

特性：

- 方法名和类名相同
- 没有返回值，不能使用void声明
- 生成类的对象时自动执行，无需调用

### 6.Java中定义一个不做事且没有参数的构造方法有什么用？
Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中”没有参数的构造方法“。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可执行。解决办法是在父类中添加一个不做事且没有参数的构造方法。

### 7.Java中创建对象的几种方式

- new关键字
- 反射
- clone
- 反序列化

### 8.抽象类和接口的区别

- 抽象类：abstract关键字修饰，一个类只能继承一个抽象类，抽象类可以有构造方法，抽象类可以有普通方法，含有抽象类的类叫抽象类，且不能被实例化
- 接口：一个类可以实现多个接口，且接口不能含有普通方法

### 9.静态变量和实例变量的区别

- 静态变量：独立存在的变量，只是位置放在某个类下，可以直接类名加点调用静态变量名使用，并且是项目或者程序一启动运行该类就直接常驻内存，不需要初始化类再调用该变量，用static关键字声明，静态方法也是同理，可以直接调用
- 实例变量：相当于该类的属性，需要先初始化该类，就是new该类后，才可以调用，但是该类未再次使用，被垃圾回收器回收后，该实例也将不存在了，就是不在内存中了。

区别：
1. 存储区域不同：静态变量存储在静态存储区，普通变量存储在堆中
2. 静态变量与类相关，普通变量则与实例相关
3. 内存分配方式不同
4. 生命周期不同

### 10.short s1 = 1;s1 = s1 + 1;有什么错？那么short s1 = 1;s1 += 1;呢？有没有错误？

1. 对于short s1 = 1; s1 = s1 +1;由于s1 + 1运算时会自动提升表达式类型，所以结果是int型，再赋值给short类型s1，编辑器报需要强制转化类型的错误。
2. 对于short s1 = 1; s1 += 1;由于+=是Java语言规定的运算符，Java编辑器会对它进行特殊处理，因此可以正确编译。

### 11.Integer和int的区别

1. Integer是int的包装类，int则是Java的一种基本数据类型
2. Integer变量必须实例化以后才能使用，而int变量不需要
3. Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值
4. Integer的默认值是null，int的默认值是0

### 12.装箱和拆箱的区别

装箱是将值类型转换成引用类型的过程；拆箱是将引用类型转换成值类型的过程

利用装箱和拆箱功能，通过允许值类型的任何值与Object类型的值进行相互转换，将引用类型与值类型连接起来

### 13.switch语句能否作用在byte上，能否作用到long上，能否作用到String上？

可以作用到int或者Integer上，由于byte、short、char都可以隐式转换为int，所以这些类型及其包装类型都可以作用。long类型不能转化为int类型，所以不可以，Java1.7以后，String可以

### 14.final、finally、finalize的区别

- final: 如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为abstract，又被声明为final。将变量或者方法声明为final，可以保证它们在使用中不被改变，被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法同样只能使用，不能重写。
- finally: 在异常处理的时提供finally块来执行任何清除操作，如果抛出一个异常，那么相匹配的catch子句就会执行，然后控制就会进入finally块，通常在处理一些资源的时候，会使用finally来关闭资源，比如文件操作，使用reentrantLock锁，分布式锁等
- finalize: 是Object类的一个方法，保证类在垃圾回收之前完成对特定资源的回收。Object类中定义的方法，Java中允许使用finalize()方法在垃圾回收器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾回收器在销毁对象时调用的，通过重写finalize()方法可以整理系统资源或者执行其他清理工作

### 15.==和equals的区别

功能不同：
“==”是判断两个变量或者实例是不是指向同一个内存空间，如果作用于基本数据类型的变量，则直接比较其储存的值是否相等，如果作用于引用类的变量，则比较的是所指向的对象的地址是否相等

“equals”是判断两个变量或实例所指向的内存空间的值是不是相同，equals()方法存在于Object类中，而Object类是所有类的直接或者间接的父类，所以说所有类中的equals()方法都继承自Object类，在没有重写equals()方法的类中，调用equals()方法其实和使用==的效果一样，也是比较的是引用类型的变量所指向对象的地址，不过Java提供的类中，有些类重写了equals()方法，重写后的equals()方法一般都是比较两个对象的值，比如String类

定义不同：

“equals”在Java中是一个方法

“==”在Java中只是一个运算符号

### 16.两个对象的hashCode相同，则equals()也一定为true吗

不一定，hashCode()相等即两个键值对的hash值相等，然后hash值相等，并不一定得出键值对相等

### 17.为什么重写equals()就一定要重写hashCode()方法

字段属性完全相同的两个对象因为hashCode不同，所以在hashMap中的table数组的下标不同，从而这两个对象就会同时存在集合中，所以重写equals()就一定要重写hashCode()方法

### 18.&和&&的区别

&左右两端条件有一个为假就会不成立，但是两端都会运行

&&也叫做短路运算符，因为只要左端条件不成立，不会去判断右端条件式，效率更高

### 19.Java中的参数传递是传值还是传引用

Java的参数传递，不管是基本数据类型还是引用数据类型，都是按值传递，没有按引用传递

### 20.如何实现对象的克隆

实现Cloneable接口并重写Object类中的clone()方法

实现Serializable接口，通过对象的序列化和反序列化实现克隆，并且实现真正的深度克隆

### 21.深克隆和浅克隆的区别

浅克隆：只复制基本类型的数据，引用类型的数据只复制了引用的地址，引用的对象并没有复制，在新的对象中修改引用类型的数据会影响原对象中的引用

深克隆：在引用类型的类中也实现了clone，是clone的嵌套，复制后的对象与原对象之间完全不会影响

### 22.什么是Java的序列化，如何实现Java的序列化

序列化：将Java对象转换成字节流的过程

反序列化：将字节流转换为Java对象的过程

类实现serializable接口，这个接口没有需要实现的方法，只是为了告诉jvm这个类的对象可以被序列化

### 23.什么情况下需要序列化

当Java对象需要在网络上传输或者持久化存储到文件中时，就需要对Java对象进行序列化处理

### 24.Java的泛型是如何工作的？什么是类型擦除？

泛型通过类型擦除来将变量变为一个类型，编译器在编译时擦除了所有类型的相关信息

`ArrayList<String>`和`ArrayList<Integer>`在运行时都被视为`ArrayList`,所以在运行时不存在任何类型相关的信息

### 25.什么时泛型中的限定通配符和非限定通配符

- 限定通配符：
`<? extends T>`它通过确保类型必须是T及T的子类来设定类型的上届；`<? super T>`它通过确保类型必须是T及T的父类设定类的下界

   例如，`<? extends Number>`表示这是一个可接受Number或Number子类的类型参数。另外，`<? super Number>`表示这是一个可接受Number或Number超类的类型参数。
- 非限定通配符:可以用任意类型来替代，非限定通配符用"?"表示。例如，`<?>`可以表示任何类型的参数。

### 26.`List<T>`和`List<?>`之间有什么区别

`List<T>`是泛型方法，`List<?>`是限制通配符

### 27.Java中的反射是什么意思？有哪些应用场景

Java反射机制是在运行状态中，对任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性，这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制

